"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function intervalCall(interval = 1000, options) {
    let globalElapsed = true;
    return fn => {
        // interval 시간 안에 다시 호출된 함수 콜은 무시한다
        let elapsed = true;
        return function (...args) {
            if ((options === null || options === void 0 ? void 0 : options.useRootContext) ? !globalElapsed : !elapsed) {
                if (options === null || options === void 0 ? void 0 : options.logCancelMessage) {
                    const fnName = (fn.name || 'anonymous function');
                    console.warn('`' + fnName + '` is canceled by intervalCall');
                }
                return; // 마지막 호출 후 제한된 경과시간이 지나지 않은 경우 리턴
            }
            if (options === null || options === void 0 ? void 0 : options.useRootContext) {
                globalElapsed = false;
            }
            else {
                elapsed = false;
            }
            setTimeout(() => {
                if (options === null || options === void 0 ? void 0 : options.useRootContext) {
                    globalElapsed = true;
                }
                else {
                    elapsed = true;
                }
            }, interval);
            return fn.call(this, ...args);
        };
    };
}
exports.default = intervalCall;
function debounce(callback, ms, immediate = false) {
    let timeout;
    let callOnce = immediate;
    return function (...args) {
        if (callOnce) {
            callback.apply(this, args);
            callOnce = false;
            return;
        }
        clearTimeout(timeout);
        timeout = setTimeout(() => callback.apply(this, args), ms);
    };
}
exports.debounce = debounce;
//# sourceMappingURL=index.js.map